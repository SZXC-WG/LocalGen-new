/**
 * @file board.hpp
 *
 * LocalGen Module: GameEngine
 *
 * Map Boards
 *
 * Container of maps.
 */

#ifndef LGEN_GAMEENGINE_BOARD_HPP
#define LGEN_GAMEENGINE_BOARD_HPP

#include <cassert>
#include <map>
#include <string>
#include <vector>

#include "move.hpp"
#include "tile.hpp"
#include "utils.hpp"

// A player's view of the board, generated by `board.view(player)`.
struct BoardView {
    pos_t row, col;
    std::vector<std::vector<TileView>> tiles;

    inline TileView& tileAt(pos_t x, pos_t y) { return tiles.at(x).at(y); };
    inline const TileView& tileAt(pos_t x, pos_t y) const {
        return tiles.at(x).at(y);
    };

    inline TileView& tileAt(Coord pos) { return tileAt(pos.x, pos.y); };
    inline const TileView& tileAt(Coord pos) const {
        return tileAt(pos.x, pos.y);
    };
};

// Game map board.
class Board {
   public:
    pos_t row = 0, col = 0;
    std::vector<std::vector<Tile>> tiles;

    inline Tile& tileAt(pos_t x, pos_t y) { return tiles.at(x).at(y); };
    inline Tile& tileAt(Coord pos) { return tileAt(pos.x, pos.y); };

    void setWidth(pos_t _col) {
        assert(_col >= 0);
        col = _col;
        for (int i = 0; i < row + 2; i++) tiles[i].resize(_col + 2);
        visionCache.clear();
    }

    void setHeight(pos_t _row) {
        assert(_row >= 0);
        row = _row;
        tiles.resize(_row + 2, std::vector<Tile>(col + 2, Tile()));
        visionCache.clear();
    }

   public:
    inline bool isValidPos(pos_t x, pos_t y) const {
        return x >= 1 && x <= row && y >= 1 && y <= col;
    }
    inline bool isValidPos(Coord pos) const { return isValidPos(pos.x, pos.y); }
    inline bool isInvalidPos(pos_t x, pos_t y) const {
        return !isValidPos(x, y);
    }
    inline bool isInvalidPos(Coord pos) const { return !isValidPos(pos); }

   public:
    inline Tile getTile(pos_t x, pos_t y) const { return tiles.at(x).at(y); }
    inline Tile getTile(Coord pos) const { return getTile(pos.x, pos.y); }
    inline int getWidth() const { return col; }
    inline int getHeight() const { return row; }

   public:
    Board() = default;
    Board(pos_t _row, pos_t _col) : row(_row), col(_col) {
        assert(row >= 0 && col >= 0);
        // board index starts at 1.
        // padding dummy tiles around for safety and convenience issues:
        tiles.resize(_row + 2, std::vector<Tile>(_col + 2, Tile()));
    }

    // Vision system.
   protected:
    // visionCache[n][x][y], flattened into 1D for better performance.
    std::vector<bool> visionCache;

   public:
    // Update the vision cache. Must be called after a board update.
    void updateVisionCache() {
        const pos_t C = col + 2, RC = (row + 2) * C;
        if (visionCache.empty()) {
            index_t maxPlayer = 0;
            for (const auto& row : tiles) {
                for (const auto& tile : row) {
                    if (tile.occupier > maxPlayer) maxPlayer = tile.occupier;
                }
            }
            visionCache.resize((maxPlayer + 1) * RC, false);
        } else {
            visionCache.assign(visionCache.size(), false);
        }

        static const std::pair<int, int> dirs[4] = {
            {-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        auto assignLookoutVision = [&](pos_t x, pos_t y) -> void {
            // 1. Find lookout occupier
            index_t occupier = -1;
            army_t maxArmy = 0;
            for (auto [dx, dy] : dirs) {
                const Tile& tile = tiles[x + dx][y + dy];
                if (tile.army > maxArmy && tile.occupier != -1) {
                    occupier = tile.occupier;
                    maxArmy = tile.army;
                }
            }
            if (occupier == -1) return;

            // 2. Assign 5x5 lookout vision
            for (pos_t i = std::max(x - 2, 1), r = std::min(x + 2, row); i <= r;
                 ++i) {
                for (pos_t j = std::max(y - 2, 1), c = std::min(y + 2, col);
                     j <= c; ++j) {
                    visionCache[occupier * RC + i * C + j] = true;
                }
            }
        };

        auto assignObservatoryVision = [&](pos_t x, pos_t y) -> void {
            for (auto [dx, dy] : dirs) {
                index_t player = tiles[x - dx][y - dy].occupier;
                if (player == -1) continue;
                int base = player * RC + x * C + y;
                int step = dx * C + dy;
                pos_t nx = x, ny = y;
                for (int i = 0; i < 8; ++i) {
                    nx += dx, ny += dy, base += step;
                    if (isInvalidPos(nx, ny)) break;
                    visionCache[base] = true;
                }
            }
        };

        const index_t numPlayers = visionCache.size() / RC;
        for (pos_t x = 1; x <= row; ++x) {
            for (pos_t y = 1; y <= col; ++y) {
                const Tile& tile = tiles[x][y];
                if (tile.lit) {
                    size_t base = x * C + y;
                    for (index_t player = 0; player < numPlayers;
                         ++player, base += RC)
                        visionCache[base] = true;
                    continue;
                }
                index_t player = tile.occupier;
                if (player == -1) {
                    tile_type_e type = tile.type;
                    if (type == TILE_LOOKOUT)
                        assignLookoutVision(x, y);
                    else if (type == TILE_OBSERVATORY)
                        assignObservatoryVision(x, y);
                } else {
                    size_t base = player * RC + x * C + y;
                    for (size_t rbase : {base - C, base, base + C}) {
                        visionCache[rbase - 1] = true;
                        visionCache[rbase] = true;
                        visionCache[rbase + 1] = true;
                    }
                }
            }
        }
    }

    // Tile visibility check for a player.
    inline bool visible(pos_t x, pos_t y, index_t player) const {
        if (isInvalidPos(x, y)) return false;
        const pos_t C = col + 2, RC = (row + 2) * C;
        return visionCache[player * RC + x * C + y];
    };

    // Same as above, but using %Coord.
    inline bool visible(const Coord& pos, index_t player) const {
        return visible(pos.x, pos.y, player);
    };

   public:
    bool available(index_t player, Move move) {
        MoveType& type = move.type;
        if (type == MoveType::EMPTY) return false;
        if (type == MoveType::SURRENDER) return true;
        Coord& from = move.from;
        Coord& to = move.to;
        if (type == MoveType::MOVE_ARMY) {
            // coordinate validity check
            if (isInvalidPos(from) || isInvalidPos(to)) return false;

            // adjacency check (orthogonal 4-neighborhood)
            bool isAdjacent = ((from.x == to.x) &&
                               (from.y + 1 == to.y || from.y - 1 == to.y)) ||
                              ((from.y == to.y) &&
                               (from.x + 1 == to.x || from.x - 1 == to.x));
            if (!isAdjacent) return false;

            // %from tile availability check
            auto fromTile = getTile(from);
            if (isImpassableTile(fromTile.type)) return false;
            if (fromTile.occupier != player) return false;
            if (fromTile.army <= 1) return false;

            // %to tile availability check
            auto toTile = getTile(to);
            if (isImpassableTile(toTile.type)) return false;

            // all passed, available move
            return true;
        }
        return false;
    };

   public:
    void update(bool increaseAllArmy = false) {
        for (auto& row : tiles) {
            for (auto& tile : row) {
                if (tile.occupier == -1) {
                    continue;
                }
                switch (tile.type) {
                    case TILE_CITY:
                    case TILE_GENERAL:
                    case TILE_CAPTURED_GENERAL: ++tile.army;
                    case TILE_BLANK:
                        if (increaseAllArmy) ++tile.army;
                        break;
                    case TILE_SWAMP:
                        if (tile.army > 0) --tile.army;
                        break;
                    default: break;
                }
                if (tile.army == 0) {
                    if (tile.type == TILE_SWAMP) tile.occupier = -1;
                }
                if (tile.army < 0) {
                    tile.occupier = -1;
                    tile.army = 0;
                }
            }
        }
    }

   public:
    BoardView view(index_t player) const {
        BoardView boardView;
        auto& tileViews = boardView.tiles;
        boardView.row = row, boardView.col = col;
        tileViews.resize(row + 2, std::vector<TileView>(col + 2));
        for (pos_t i = 1; i <= row; ++i) {
            for (pos_t j = 1; j <= col; ++j) {
                tileViews[i][j].updateFrom(tiles[i][j], visible(i, j, player));
            }
        }
        return boardView;
    }

    BoardView fullView() const {
        BoardView boardView;
        auto& tileViews = boardView.tiles;
        boardView.row = row, boardView.col = col;
        tileViews.resize(row + 2, std::vector<TileView>(col + 2));
        for (pos_t i = 1; i <= row; ++i) {
            for (pos_t j = 1; j <= col; ++j) {
                tileViews[i][j].updateFrom(tiles[i][j], true);
            }
        }
        return boardView;
    }

    inline TileView view(index_t player, pos_t row, pos_t col) const {
        return TileView(getTile(row, col), visible(row, col, player));
    }
    inline TileView view(index_t player, Coord pos) const {
        return TileView(getTile(pos), visible(pos, player));
    };
};

// Derived class for initial boards (pre-game boards).
class InitBoard : public Board {
   public:
    InitBoard() = default;
    InitBoard(pos_t row, pos_t col) : Board(row, col) {};

   public:
    using Board::getTile;
    using Board::setHeight;
    using Board::setWidth;

   public:
    // Spawns and team preferences
    std::map<Coord, unsigned> spawns;

    inline void changeTile(Coord pos, Tile tile) {
        assert(isValidPos(pos));
        tileAt(pos) = tile;
        if (tile.type == TILE_SPAWN)
            setSpawn(pos, 0);
        else
            spawns.erase(pos);
    };

    // Set attributes of a spawn.
    // @param team The team preference of the spawn.
    inline void setSpawn(Coord pos, unsigned team) {
        assert(isValidPos(pos));
        if (tileAt(pos).type != TILE_SPAWN) tileAt(pos).type = TILE_SPAWN;
        spawns[pos] = team;
    };

    // Get the team preference of a spawn.
    // @return The team preference of the spawn.
    inline unsigned getSpawnTeam(Coord pos) {
        assert(isValidPos(pos) && tileAt(pos).type == TILE_SPAWN);
        return spawns.at(pos);
    };

    // Map coding system derived from v5.
    // v6 is designed to be compatible with v5, so we saved this system.
   private:
    static inline intmax_t PMod(intmax_t& x) {
        intmax_t res = x & 63;  // 63 = 0b111111
        x >>= 6;
        return res;
    };
    static constexpr int CHAR_AD = 48;

   public:
    std::string v5Zip() {
        std::string strZip;
        int i, j;
        intmax_t k1 = row, k2 = col;
        strZip.push_back(PMod(k1) + CHAR_AD);
        strZip.push_back(PMod(k1) + CHAR_AD);
        strZip.push_back(PMod(k2) + CHAR_AD);
        strZip.push_back(PMod(k2) + CHAR_AD);

        for (i = 1; i <= row; i++)
            for (j = 1; j <= col; j++) {
                strZip.push_back(tiles[i][j].occupier + CHAR_AD);

                int type = 0;
                switch (tiles[i][j].type) {
                    case TILE_BLANK:       type = 0; break;
                    case TILE_SWAMP:       type = 1; break;
                    case TILE_MOUNTAIN:    type = 2; break;
                    case TILE_SPAWN:       type = 3; break;
                    case TILE_CITY:        type = 4; break;
                    case TILE_DESERT:      type = 5; break;
                    case TILE_LOOKOUT:     type = 6; break;
                    case TILE_OBSERVATORY: type = 7; break;
                    default:               break;
                }

                char ch = (type << 2) + (tiles[i][j].lit << 1);
                k1 = tiles[i][j].army;

                if (k1 < 0) {
                    k1 = -k1;
                    strZip.push_back(ch += CHAR_AD + 1);
                } else
                    strZip.push_back(ch += CHAR_AD);

                for (k2 = 1; k2 <= 8; k2++)
                    strZip.push_back(PMod(k1) + CHAR_AD);
            }
        return strZip;
    };

    void v5Unzip(std::string strUnzip) {
        strUnzip.push_back('\0');

        int i, j, k = 4;
        int f, p = 0;

        for (; strUnzip[p] != '\0'; p++) strUnzip[p] -= CHAR_AD;

        row = (strUnzip[1] << 6) + strUnzip[0];
        col = (strUnzip[3] << 6) + strUnzip[2];
        tiles.resize(row + 2, std::vector<Tile>(col + 2));

        for (i = 1; i <= row; i++)
            for (j = 1; j <= col; j++) {
                tiles[i][j].occupier = strUnzip[k++];
                if (tiles[i][j].occupier == 0) tiles[i][j].occupier = -1;
                bool f = strUnzip[k] & 1;
                strUnzip[k] >>= 1;
                tiles[i][j].lit = strUnzip[k] & 1;
                strUnzip[k] >>= 1;
                int type = strUnzip[k++];
                tiles[i][j].army = 0;

                switch (type) {
                    case 0:  tiles[i][j].type = TILE_BLANK; break;
                    case 1:  tiles[i][j].type = TILE_SWAMP; break;
                    case 2:  tiles[i][j].type = TILE_MOUNTAIN; break;
                    case 3:  tiles[i][j].type = TILE_SPAWN; break;
                    case 4:  tiles[i][j].type = TILE_CITY; break;
                    case 5:  tiles[i][j].type = TILE_DESERT; break;
                    case 6:  tiles[i][j].type = TILE_LOOKOUT; break;
                    case 7:  tiles[i][j].type = TILE_OBSERVATORY; break;
                    default: break;
                }

                for (p = 7; p >= 0; p--)
                    tiles[i][j].army =
                        (tiles[i][j].army << 6) + strUnzip[k + p];
                k += 8;
                tiles[i][j].army = f ? (-tiles[i][j].army) : tiles[i][j].army;
            }
    };
};

#endif  // LGEN_GAMEENGINE_BOARD_HPP
