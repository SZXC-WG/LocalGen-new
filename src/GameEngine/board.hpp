/**
 * @file board.hpp
 *
 * LocalGen Module: GameEngine
 *
 * Map Boards
 *
 * Container of maps.
 */

#ifndef LGEN_GAMEENGINE_BOARD_HPP
#define LGEN_GAMEENGINE_BOARD_HPP

#include <cassert>
#include <map>
#include <string>
#include <vector>

#include "move.hpp"
#include "tile.hpp"
#include "utils.hpp"

/// A player's view of the board, generated by `board.view(player)`.
struct BoardView {
    pos_t row, col;
    std::vector<std::vector<TileView>> tiles;

    inline TileView& tileAt(pos_t x, pos_t y) { return tiles.at(x).at(y); };
    inline const TileView& tileAt(pos_t x, pos_t y) const {
        return tiles.at(x).at(y);
    };

    inline TileView& tileAt(Coord pos) { return tileAt(pos.x, pos.y); };
    inline const TileView& tileAt(Coord pos) const {
        return tileAt(pos.x, pos.y);
    };
};

/// Game map board.
class Board {
   public:
    pos_t row = 0, col = 0;
    std::vector<std::vector<Tile>> tiles;

    inline Tile& tileAt(pos_t x, pos_t y) { return tiles.at(x).at(y); };
    inline Tile& tileAt(Coord pos) { return tileAt(pos.x, pos.y); };

    void setWidth(pos_t _col) {
        assert(_col >= 0);
        col = _col;
        for (int i = 0; i < row + 2; i++) tiles[i].resize(_col + 2);
    }

    void setHeight(pos_t _row) {
        assert(_row >= 0);
        row = _row;
        tiles.resize(_row + 2, std::vector<Tile>(col + 2, Tile()));
    }

   public:
    inline bool isValidPos(pos_t x, pos_t y) const {
        return x >= 1 && x <= row && y >= 1 && y <= col;
    }
    inline bool isValidPos(Coord pos) const { return isValidPos(pos.x, pos.y); }
    inline bool isInvalidPos(pos_t x, pos_t y) const {
        return !isValidPos(x, y);
    }
    inline bool isInvalidPos(Coord pos) const { return !isValidPos(pos); }

   public:
    inline Tile getTile(pos_t x, pos_t y) const { return tiles.at(x).at(y); }
    inline Tile getTile(Coord pos) const { return getTile(pos.x, pos.y); }
    inline int getWidth() const { return col; }
    inline int getHeight() const { return row; }

   public:
    Board() = default;
    Board(pos_t _row, pos_t _col) : row(_row), col(_col) {
        assert(row >= 0 && col >= 0);
        // board index starts at 1.
        // padding dummy tiles around for safety and convenience issues:
        tiles.resize(_row + 2, std::vector<Tile>(_col + 2, Tile()));
    }

   public:
    /// Check whether the %Tile at (x,y) is visible to a %Player.
    bool visible(pos_t x, pos_t y, index_t player) const {
        // invalidity check
        if (isInvalidPos(x, y)) return false;
        if (tiles[x][y].lit) return true;

        // occupier & adjacent check
        for (int dx = -1; dx <= 1; ++dx)
            for (int dy = -1; dy <= 1; ++dy)
                if (tiles[x + dx][y + dy].occupier == player) return true;

        // lookout check
        auto getLookoutOccupier = [&](pos_t x, pos_t y) {
            index_t occupier = -1;
            army_t maxArmy = 0;
            for (int dx = -1; dx <= 1; ++dx)
                for (int dy = -1; dy <= 1; ++dy) {
                    const auto& tile = tiles[x + dx][y + dy];
                    if (tile.army > maxArmy) {
                        occupier = tile.occupier;
                        maxArmy = tile.army;
                    }
                }
            return occupier;
        };
        for (pos_t i = std::max(x - 2, 1), r = std::min(x + 2, row); i <= r;
             ++i) {
            for (pos_t j = std::max(y - 2, 1), c = std::min(y + 2, col); j <= c;
                 ++j) {
                if (tiles[i][j].type == TILE_LOOKOUT &&
                    getLookoutOccupier(i, j) == player)
                    return true;
            }
        }

        // observatory check
        for (pos_t i = std::max(x - 8, 1); i < x; ++i) {
            if (tiles[i][y].type == TILE_OBSERVATORY &&
                tiles[i - 1][y].occupier == player)
                return true;
        }
        for (pos_t i = x + 1, r = std::min(x + 8, row); i <= r; ++i) {
            if (tiles[i][y].type == TILE_OBSERVATORY &&
                tiles[i + 1][y].occupier == player)
                return true;
        }
        for (pos_t j = std::max(y - 8, 1); j < y; ++j) {
            if (tiles[x][j].type == TILE_OBSERVATORY &&
                tiles[x][j - 1].occupier == player)
                return true;
        }
        for (pos_t j = y + 1, c = std::min(y + 8, col); j <= c; ++j) {
            if (tiles[x][j].type == TILE_OBSERVATORY &&
                tiles[x][j + 1].occupier == player)
                return true;
        }

        // No match - not visible
        return false;
    };

    /// Same as above, but using %Coord.
    inline bool visible(const Coord& pos, index_t player) const {
        return visible(pos.x, pos.y, player);
    };

   public:
    bool available(index_t player, Move move) {
        MoveType& type = move.type;
        if (type == MoveType::EMPTY) return false;
        if (type == MoveType::SURRENDER) return true;
        Coord& from = move.from;
        Coord& to = move.to;
        if (type == MoveType::MOVE_ARMY) {
            // coordinate validity check
            if (isInvalidPos(from) || isInvalidPos(to)) return false;

            // adjacency check (orthogonal 4-neighborhood)
            bool isAdjacent = ((from.x == to.x) &&
                               (from.y + 1 == to.y || from.y - 1 == to.y)) ||
                              ((from.y == to.y) &&
                               (from.x + 1 == to.x || from.x - 1 == to.x));
            if (!isAdjacent) return false;

            // %from tile availability check
            auto fromTile = getTile(from);
            if (isImpassableTile(fromTile.type)) return false;
            if (fromTile.occupier != player) return false;
            if (fromTile.army <= 1) return false;

            // %to tile availability check
            auto toTile = getTile(to);
            if (isImpassableTile(toTile.type)) return false;

            // all passed, available move
            return true;
        }
        return false;
    };

   public:
    void update(bool increaseAllArmy = false) {
        for (auto& row : tiles) {
            for (auto& tile : row) {
                if (tile.occupier == -1) {
                    continue;
                }
                switch (tile.type) {
                    case TILE_CITY:
                    case TILE_GENERAL:
                    case TILE_CAPTURED_GENERAL: ++tile.army;
                    case TILE_BLANK:
                        if (increaseAllArmy) ++tile.army;
                        break;
                    case TILE_SWAMP:
                        if (tile.army > 0) --tile.army;
                        break;
                    default: break;
                }
                if (tile.army == 0) {
                    if (tile.type == TILE_SWAMP) tile.occupier = -1;
                }
                if (tile.army < 0) {
                    tile.occupier = -1;
                    tile.army = 0;
                }
            }
        }
    }

   public:
    BoardView view(index_t player) const {
        BoardView boardView;
        auto& tileViews = boardView.tiles;
        boardView.row = row, boardView.col = col;
        tileViews.resize(row + 2, std::vector<TileView>(col + 2));
        for (pos_t i = 1; i <= row; ++i) {
            for (pos_t j = 1; j <= col; ++j) {
                tileViews[i][j].updateFrom(tiles[i][j], visible(i, j, player));
            }
        }
        return boardView;
    }

    BoardView fullView() const {
        BoardView boardView;
        auto& tileViews = boardView.tiles;
        boardView.row = row, boardView.col = col;
        tileViews.resize(row + 2, std::vector<TileView>(col + 2));
        for (pos_t i = 1; i <= row; ++i) {
            for (pos_t j = 1; j <= col; ++j) {
                tileViews[i][j].updateFrom(tiles[i][j], true);
            }
        }
        return boardView;
    }

    inline TileView view(index_t player, pos_t row, pos_t col) const {
        return TileView(getTile(row, col), visible(row, col, player));
    }
    inline TileView view(index_t player, Coord pos) const {
        return TileView(getTile(pos), visible(pos, player));
    };
};

/// Derived class for initial boards (pre-game boards).
class InitBoard : public Board {
   public:
    InitBoard() = default;
    InitBoard(pos_t row, pos_t col) : Board(row, col) {};

   public:
    using Board::getTile;
    using Board::setHeight;
    using Board::setWidth;

   public:
    /// Spawns and team preferences
    std::map<Coord, unsigned> spawns;

    inline void changeTile(Coord pos, Tile tile) {
        assert(isValidPos(pos));
        tileAt(pos) = tile;
        if (tile.type == TILE_SPAWN)
            setSpawn(pos, 0);
        else
            spawns.erase(pos);
    };

    /// Set attributes of a spawn.
    /// @param team The team preference of the spawn.
    inline void setSpawn(Coord pos, unsigned team) {
        assert(isValidPos(pos));
        if (tileAt(pos).type != TILE_SPAWN) tileAt(pos).type = TILE_SPAWN;
        spawns[pos] = team;
    };

    /// Get the team preference of a spawn.
    /// @return The team preference of the spawn.
    inline unsigned getSpawnTeam(Coord pos) {
        assert(isValidPos(pos) && tileAt(pos).type == TILE_SPAWN);
        return spawns.at(pos);
    };

    /// Map coding system derived from v5.
    /// v6 is designed to be compatible with v5, so we saved this system.
   private:
    static inline intmax_t PMod(intmax_t& x) {
        intmax_t res = x & 63;  // 63 = 0b111111
        x >>= 6;
        return res;
    };
    static constexpr int CHAR_AD = 48;

   public:
    std::string v5Zip() {
        std::string strZip;
        int i, j;
        intmax_t k1 = row, k2 = col;
        strZip.push_back(PMod(k1) + CHAR_AD);
        strZip.push_back(PMod(k1) + CHAR_AD);
        strZip.push_back(PMod(k2) + CHAR_AD);
        strZip.push_back(PMod(k2) + CHAR_AD);

        for (i = 1; i <= row; i++)
            for (j = 1; j <= col; j++) {
                strZip.push_back(tiles[i][j].occupier + CHAR_AD);

                int type = 0;
                switch (tiles[i][j].type) {
                    case TILE_BLANK:       type = 0; break;
                    case TILE_SWAMP:       type = 1; break;
                    case TILE_MOUNTAIN:    type = 2; break;
                    case TILE_SPAWN:       type = 3; break;
                    case TILE_CITY:        type = 4; break;
                    case TILE_DESERT:      type = 5; break;
                    case TILE_LOOKOUT:     type = 6; break;
                    case TILE_OBSERVATORY: type = 7; break;
                    default:               break;
                }

                char ch = (type << 2) + (tiles[i][j].lit << 1);
                k1 = tiles[i][j].army;

                if (k1 < 0) {
                    k1 = -k1;
                    strZip.push_back(ch += CHAR_AD + 1);
                } else
                    strZip.push_back(ch += CHAR_AD);

                for (k2 = 1; k2 <= 8; k2++)
                    strZip.push_back(PMod(k1) + CHAR_AD);
            }
        return strZip;
    };

    void v5Unzip(std::string strUnzip) {
        strUnzip.push_back('\0');

        int i, j, k = 4;
        int f, p = 0;

        for (; strUnzip[p] != '\0'; p++) strUnzip[p] -= CHAR_AD;

        row = (strUnzip[1] << 6) + strUnzip[0];
        col = (strUnzip[3] << 6) + strUnzip[2];
        tiles.resize(row + 2, std::vector<Tile>(col + 2));

        for (i = 1; i <= row; i++)
            for (j = 1; j <= col; j++) {
                tiles[i][j].occupier = strUnzip[k++];
                if (tiles[i][j].occupier == 0) tiles[i][j].occupier = -1;
                bool f = strUnzip[k] & 1;
                strUnzip[k] >>= 1;
                tiles[i][j].lit = strUnzip[k] & 1;
                strUnzip[k] >>= 1;
                int type = strUnzip[k++];
                tiles[i][j].army = 0;

                switch (type) {
                    case 0:  tiles[i][j].type = TILE_BLANK; break;
                    case 1:  tiles[i][j].type = TILE_SWAMP; break;
                    case 2:  tiles[i][j].type = TILE_MOUNTAIN; break;
                    case 3:  tiles[i][j].type = TILE_SPAWN; break;
                    case 4:  tiles[i][j].type = TILE_CITY; break;
                    case 5:  tiles[i][j].type = TILE_DESERT; break;
                    case 6:  tiles[i][j].type = TILE_LOOKOUT; break;
                    case 7:  tiles[i][j].type = TILE_OBSERVATORY; break;
                    default: break;
                }

                for (p = 7; p >= 0; p--)
                    tiles[i][j].army =
                        (tiles[i][j].army << 6) + strUnzip[k + p];
                k += 8;
                tiles[i][j].army = f ? (-tiles[i][j].army) : tiles[i][j].army;
            }
    };
};

#endif  // LGEN_GAMEENGINE_BOARD_HPP
