/**
 * @file board.hpp
 *
 * LocalGen Module: GameEngine
 *
 * Map Boards
 *
 * Container of maps.
 */

#ifndef LGEN_GAMEENGINE_BOARD_HPP
#define LGEN_GAMEENGINE_BOARD_HPP

#include <algorithm>
#include <cassert>
#include <string>
#include <vector>

#include "move.hpp"
#include "tile.hpp"
#include "utils.hpp"

/// A player's view of the board, generated by `board.view(player)`.
struct BoardView {
    pos_t row, col;
    std::vector<std::vector<TileView>> tiles;

    inline TileView& tileAt(pos_t x, pos_t y) { return tiles.at(x).at(y); };
    inline TileView& tileAt(Coord pos) { return tileAt(pos.x, pos.y); };
};

/// Game map board.
class Board {
   protected:
    pos_t row = 0, col = 0;
    std::vector<std::vector<Tile>> tiles;

    inline Tile& tileAt(pos_t x, pos_t y) { return tiles.at(x).at(y); };
    inline Tile& tileAt(Coord pos) { return tileAt(pos.x, pos.y); };

    void setWidth(pos_t _col) {
        assert(_col >= 0);
        col = _col;
        for (int i = 0; i < row + 2; i++) tiles[i].resize(_col + 2);
    }

    void setHeight(pos_t _row) {
        assert(_row >= 0);
        row = _row;
        tiles.resize(_row + 2, std::vector<Tile>(col + 2, Tile()));
    }

   public:
    inline bool isValidPos(pos_t x, pos_t y) const {
        return x >= 1 && x <= row && y >= 1 && y <= col;
    }
    inline bool isValidPos(Coord pos) const { return isValidPos(pos.x, pos.y); }
    inline bool isInvalidPos(pos_t x, pos_t y) const {
        return !isValidPos(x, y);
    }
    inline bool isInvalidPos(Coord pos) const { return !isValidPos(pos); }

   public:
    inline Tile getTile(pos_t x, pos_t y) const { return tiles.at(x).at(y); }
    inline Tile getTile(Coord pos) const { return getTile(pos.x, pos.y); }
    inline int getWidth() const { return col; }
    inline int getHeight() const { return row; }

   public:
    Board() = default;
    Board(pos_t _row, pos_t _col) : row(_row), col(_col) {
        assert(row >= 0 && col >= 0);
        // board index starts at 1.
        // padding dummy tiles around for safety and convenience issues:
        tiles.resize(_row + 2, std::vector<Tile>(_col + 2, Tile()));
    }

    /// Map coding system derived from v5.
    /// v6 is designed to be compatible with v5, so we saved this system.
   private:
    static inline intmax_t PMod(intmax_t& x) {
        intmax_t res = x & 63;  // 63 = 0b111111
        x >>= 6;
        return res;
    };
    static constexpr int CHAR_AD = 48;

   public:
    std::string v5Zip() {
        std::string strZip;
        int i, j;
        intmax_t k1 = row, k2 = col;
        strZip.push_back(PMod(k1) + CHAR_AD);
        strZip.push_back(PMod(k1) + CHAR_AD);
        strZip.push_back(PMod(k2) + CHAR_AD);
        strZip.push_back(PMod(k2) + CHAR_AD);

        for (i = 1; i <= row; i++)
            for (j = 1; j <= col; j++) {
                strZip.push_back(tiles[i][j].occupier + CHAR_AD);

                int type = 0;
                switch (tiles[i][j].type) {
                    case TILE_BLANK:       type = 0; break;
                    case TILE_SWAMP:       type = 1; break;
                    case TILE_MOUNTAIN:    type = 2; break;
                    case TILE_SPAWN:       type = 3; break;
                    case TILE_CITY:        type = 4; break;
                    case TILE_DESERT:      type = 5; break;
                    case TILE_LOOKOUT:     type = 6; break;
                    case TILE_OBSERVATORY: type = 7; break;
                    default:               break;
                }

                char ch = (type << 2) + (tiles[i][j].lit << 1);
                k1 = tiles[i][j].army;

                if (k1 < 0) {
                    k1 = -k1;
                    strZip.push_back(ch += CHAR_AD + 1);
                } else
                    strZip.push_back(ch += CHAR_AD);

                for (k2 = 1; k2 <= 8; k2++)
                    strZip.push_back(PMod(k1) + CHAR_AD);
            }
        return strZip;
    };

    void v5Unzip(std::string strUnzip) {
        strUnzip.push_back('\0');

        int i, j, k = 4;
        int f, p = 0;

        for (; strUnzip[p] != '\0'; p++) strUnzip[p] -= CHAR_AD;

        row = (strUnzip[1] << 6) + strUnzip[0];
        col = (strUnzip[3] << 6) + strUnzip[2];
        tiles.resize(row + 2, std::vector<Tile>(col + 2));

        for (i = 1; i <= row; i++)
            for (j = 1; j <= col; j++) {
                tiles[i][j].occupier = strUnzip[k++];
                if (tiles[i][j].occupier == 0) tiles[i][j].occupier = -1;
                bool f = strUnzip[k] & 1;
                strUnzip[k] >>= 1;
                tiles[i][j].lit = strUnzip[k] & 1;
                strUnzip[k] >>= 1;
                int type = strUnzip[k++];
                tiles[i][j].army = 0;

                switch (type) {
                    case 0:  tiles[i][j].type = TILE_BLANK; break;
                    case 1:  tiles[i][j].type = TILE_SWAMP; break;
                    case 2:  tiles[i][j].type = TILE_MOUNTAIN; break;
                    case 3:  tiles[i][j].type = TILE_SPAWN; break;
                    case 4:  tiles[i][j].type = TILE_CITY; break;
                    case 5:  tiles[i][j].type = TILE_DESERT; break;
                    case 6:  tiles[i][j].type = TILE_LOOKOUT; break;
                    case 7:  tiles[i][j].type = TILE_OBSERVATORY; break;
                    default: break;
                }

                for (p = 7; p >= 0; p--)
                    tiles[i][j].army =
                        (tiles[i][j].army << 6) + strUnzip[k + p];
                k += 8;
                tiles[i][j].army = f ? (-tiles[i][j].army) : tiles[i][j].army;
            }
    };

   public:
    /// Check whether the %Tile at (x,y) is visible to a %Player.
    virtual bool visible(pos_t x, pos_t y, index_t player) const {
        // invalidity check
        if (x < 1 || x > col || y < 1 || y > row) return false;

        // occupier visibility
        if (tiles[x][y].occupier == player) return true;
        // adjacent visibility
        if (true &&  // overall check may not consider modifiers
            (tiles[x - 1][y].occupier == player ||
             tiles[x + 1][y].occupier == player ||
             tiles[x][y - 1].occupier == player ||
             tiles[x][y + 1].occupier == player ||
             tiles[x - 1][y - 1].occupier == player ||
             tiles[x - 1][y + 1].occupier == player ||
             tiles[x + 1][y - 1].occupier == player ||
             tiles[x + 1][y + 1].occupier == player))
            return true;

        // lookout check
        auto findLookoutOccupier = [&](pos_t x, pos_t y) {
            index_t occupier = -1;
            army_t maxArmy = 0;
            if (tiles[x - 1][y].army > maxArmy)
                occupier = tiles[x - 1][y].occupier,
                maxArmy = tiles[x - 1][y].army;
            if (tiles[x + 1][y].army > maxArmy)
                occupier = tiles[x + 1][y].occupier,
                maxArmy = tiles[x + 1][y].army;
            if (tiles[x][y - 1].army > maxArmy)
                occupier = tiles[x][y - 1].occupier,
                maxArmy = tiles[x][y - 1].army;
            if (tiles[x][y + 1].army > maxArmy)
                occupier = tiles[x][y + 1].occupier,
                maxArmy = tiles[x][y + 1].army;
            if (tiles[x - 1][y - 1].army > maxArmy)
                occupier = tiles[x - 1][y].occupier,
                maxArmy = tiles[x - 1][y].army;
            if (tiles[x - 1][y + 1].army > maxArmy)
                occupier = tiles[x - 1][y].occupier,
                maxArmy = tiles[x - 1][y].army;
            if (tiles[x + 1][y - 1].army > maxArmy)
                occupier = tiles[x - 1][y].occupier,
                maxArmy = tiles[x - 1][y].army;
            if (tiles[x + 1][y + 1].army > maxArmy)
                occupier = tiles[x - 1][y].occupier,
                maxArmy = tiles[x - 1][y].army;
            return occupier;
        };
        for (pos_t i = std::max(x - 2, 1); i <= std::min(x + 2, row); ++i) {
            for (pos_t j = std::max(y - 2, 1); j <= std::min(y + 2, col); ++j) {
                if (tiles[i][j].type == TILE_LOOKOUT)
                    if (findLookoutOccupier(i, j) == player) return true;
            }
        }

        // observatory check
        for (pos_t i = std::max(x - 8, 1); i < x; ++i) {
            if (tiles[i][y].type == TILE_OBSERVATORY)
                if (tiles[i - 1][y].occupier == player) return true;
        }
        for (pos_t i = x + 1; i <= std::min(x + 8, row); ++i) {
            if (tiles[i][y].type == TILE_OBSERVATORY)
                if (tiles[i + 1][y].occupier == player) return true;
        }
        for (pos_t j = std::max(y - 8, 1); j < y; ++j) {
            if (tiles[x][j].type == TILE_OBSERVATORY)
                if (tiles[x][j - 1].occupier == player) return true;
        }
        for (pos_t j = y + 1; j <= std::min(y + 8, col); ++j) {
            if (tiles[x][j].type == TILE_OBSERVATORY)
                if (tiles[x][j + 1].occupier == player) return true;
        }

        // none matches, not visible
        return false;
    };

    /// Same as above, but using %Coord.
    inline bool visible(const Coord& pos, index_t player) const {
        return visible(pos.x, pos.y, player);
    };

   public:
    bool available(index_t player, Move move) {
        MoveType& type = move.type;
        if (type == MoveType::EMPTY) return false;
        if (type == MoveType::SURRENDER) return true;
        Coord& from = move.from;
        Coord& to = move.to;
        if (type == MoveType::MOVE_ARMY) {
            // coordinate validity check
            if (isInvalidPos(from) || isInvalidPos(to)) return false;

            // %from tile availability check
            auto fromTile = view(player, from);
            switch (fromTile.type) {
                case TILE_MOUNTAIN:
                case TILE_LOOKOUT:
                case TILE_OBSERVATORY: return false;
            }
            if (fromTile.occupier != player) return false;
            if (fromTile.army <= 1) return false;

            // %to tile availability check
            auto toTile = view(player, to);
            switch (toTile.type) {
                case TILE_MOUNTAIN:
                case TILE_LOOKOUT:
                case TILE_OBSERVATORY: return false;
            }

            // all passed, available move
            return true;
        }
        return false;
    };

   public:
    BoardView view(index_t player) const {
        BoardView boardView;
        auto& tileViews = boardView.tiles;
        boardView.row = row, boardView.col = col;
        tileViews.resize(row + 2, std::vector<TileView>(col + 2));
        for (pos_t i = 1; i <= row; ++i) {
            for (pos_t j = 1; j <= col; ++j) {
                tileViews[i][j].updateFrom(tiles[i][j], visible(i, j, player));
            }
        }
        return boardView;
    }

    inline TileView view(index_t player, pos_t row, pos_t col) const {
        return TileView(getTile(row, col), visible(row, col, player));
    }
    inline TileView view(index_t player, Coord pos) const {
        return TileView(getTile(pos), visible(pos, player));
    };
};

/// Derived class for initial boards (pre-game boards).
class InitBoard : public Board {
   public:
    InitBoard() = default;
    InitBoard(pos_t row, pos_t col) : Board(row, col) {};

   public:
    using Board::getTile;
    using Board::setHeight;
    using Board::setWidth;

   public:
    /// Spawns and team preferences
    std::vector<std::pair<Coord, int>> spawns;

    inline void changeTile(Coord pos, Tile tile) {
        assert(isValidPos(pos));
        setSpawn(pos, 0);
        tileAt(pos) = tile;
    };

    /// Set attributes of a spawn.
    /// @param team The team preference of the spawn.
    inline void setSpawn(Coord pos, unsigned team) {
        assert(isValidPos(pos));
        if (tileAt(pos).type != TILE_SPAWN) {
            tileAt(pos).type = TILE_SPAWN;
            spawns.emplace_back(pos, team);
            return;
        }
        std::sort(spawns.begin(), spawns.end());
        std::lower_bound(spawns.begin(), spawns.end(), std::pair(pos, 0))
            ->second = team;
    };

    /// Get the team preference of a spawn.
    /// @return The team preference of the spawn.
    inline int getSpawnTeam(Coord pos) {
        assert(isValidPos(pos) && tileAt(pos).type == TILE_SPAWN);
        return std::lower_bound(spawns.begin(), spawns.end(), std::pair(pos, 0))
            ->second;
    };
};

#endif  // LGEN_GAMEENGINE_BOARD_HPP
